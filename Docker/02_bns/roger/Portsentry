https://www.securitylab.ru/analytics/216206.php
https://www.securitylab.ru/analytics/216217.php

Главная цель PortSentry – обнаружить сканирование портов на хосте и отреагировать на такие просмотры. 
Это - одна из причин, по которой PortSentry должен рассматриваться, как утилита обнаружения вторжения. 
Если атакующий не знает заранее, какие порты открыты и доступны в системе, он начнет сканирование, для того чтобы определить доступные сервисы. 
В этот момент вступает в игру PortSentry. Инструмент контролирует и UDP порты на системе и, в зависимости от конфигурации, ответит на 
идентифицированный просмотр.

PortSentry контролирует TCP и UDP просмотры и способен обнаруживать большинство методов скрытого сканирования инструментами, типа Nmap. 
Вот некоторые из обнаруживаемых методов:

Connect scans – сканирование с полным подключением. В этом методе используется TCP функция connect() для установления соединения. 
В методе используются все три стадии установления подключения, поэтому его легко обнаружить.

SYN scans – так же известен как "half-open" scans – один из распространенных методов скрытого сканирования портов.  
В этом методе используются только две из трех стадий установления соединения. Атакующая система посылает TCP SYN пакет, как бы запрашивая 
установление соединения. Хост отвечает ей SYN-ACK пакетом. Инициатор затем посылает TCP RST пакет назад адресату, таким образом, 
закрывая подключение. Идея состоит в том, что такие неполные подключения обычно не регистрируются системой.

FIN scans – это сканирование использует пакеты с установленным флагом TCP FIN. Обычно FIN пакеты используются только в заключительной 
последовательности подключения. Непредусмотренные FIN пакеты, посланные закрытому TCPпорту, генерируют недопустимые пакеты с другой стороны.

NULL SCANS – использует пакет без установленных TCP флажков. Согласно RFC 793, это приведет к генерации недопустимого пакета с другой стороны.

XMAS scans – использует набор FIN, URG и PUSH TCP флажков в TCP заголовке. Такой набор не может встретиться в нормальном пакете, тем самым, 
такой пакет заставляет закрытый порт сгенерировать недопустимый RST.

FULL-XMAS scan – этот тип сканирования использует все установленные TCP флажки (SYN,ACK,RST, FIN,URG,PSH). Такие типы пакетов также 
в природе не встречаются.

UDP scan – этот тип сканирование обнаруживается присутствием множества UDP пакетов, исходящих с отдельного IP адреса.

Если PortSentry не может идентифицировать просмотр, как один из вышеупомянутых, он использует заданный по умолчанию набор правил, 
которые будут идентифицировать такое сканирование. Большинство других средств обнаружения сканирования, в отличие от PortSentry, 
будут фактически игнорировать "неопознанные" просмотры.

Одним из препятствий, с которым сталкивается PortSentry, это определение, является ли пакет частью сканирования, или он составляет часть 
нормального трафика для данного порта. PortSentry использует для этого два метода: сначала он игнорирует порты, которые находятся в 
использовании (связанны с соответствующей службой). Во вторых, пользователь определяет список портов, контролируемых PortSentry, 
в файле конфигурации. Если порт в списке файла конфигурации совпадает с используемым, то такой порт игнорируется PortSentry.

Одна из прекрасных особенностей PortSentry – это интеллектуальный контроль портов. Для проколов типа FTP, в которых клиент открывает порты в 
эфемерном диапазоне (TCP порты выше 1024) и сервер устанавливает обратное подключение с хостом, PortSentry может исследовать поступающее 
подключение, и если оно предназначено для одного из эфемерных портов, оно будет проигнорировано. Как только подключение завершено, 
PortSentry продолжит следить за таким портом в обычном режиме.

Проверка просмотров TCP или UDP портов – не единственные методы, которые используются для обнаружения просмотра. 
Если длина IP заголовка меньше 5 (минимальная длина, указанная в RFC 791), PortSentry регистрирует такое сообщение. 
Точно так же, если установлены любые IP опции, PortSentry также обращает на них внимание. Хотя может показаться проблематично 
использование опций типа source-routing, record-route или timestamp, они могут использоваться нападающим для сбора разведывательной информации.  


Внутренняя структура
В простейшем случае, PortSentry контролирует порты на наличие потенциально подозрительных пакетов, реагируя, если просмотр был обнаружен. 
Чтобы это осуществить, PortSentry должен удерживать состояние слежки за всеми IP адресами, которые пытаются установить подключение с хостом.

PortSentry использует внутренний движок состояния в форме массива IP адресов, который определяет, соединялся ли хост ранее с системой. 
Массив - двумерная таблица, состоящая из IP-адреса и счетчика. Когда происходит сканирование адресата (случайный или последовательный просмотр), 
PortSentry проверяет массив, чтобы определить, был ли IP атакующего замечен прежде, и, если это так, то счетчик увеличивается. 
Эту процедуру он делает для каждого порта, контролируя и обнаруживая пакеты, приходящие с IP-адреса атакующего. 
Как только триггер достиг определенного значения, PortSentry среагирует на просмотр.

Метод, которым PortSentry реагирует на просмотр, изменяется, в зависимости от настроек пользователя в файле конфигурации. 
PortSentry обеспечивает три пути предотвращения дальнейшего просмотра, которые детально будут рассмотрены ниже. 
Все три метода блокирования хоста имеют свои риски и выгоды.

Методы блокирования
 Первый метод изменяет таблицу маршрутизации так, что весь трафик с подозрительного IP будет послан в некоторый “приемник”. 
 Используя таблицу маршрутизации хоста, он будет переправлен по неправильному адресу от просматриваемого хоста до несуществующего IP адреса. 
 В этом случае, PortSentry напоминает черную дыру - трафик приходит, но не возвращается. Проблема с этим методом состоит в том, 
 что он увеличивает размер таблицы маршрутизации на хосте. Поскольку таблица маршрутизации растет, необходимо большее количество памяти 
 для запоминания маршрутов. Теоретически, нападающий может подделывать исходный адрес пакетов, используемых в просмотре, 
 заставляя беспорядочно PortSentry добавлять записи в таблицы маршрута в ответе. Это, теоретически, может привести к исчерпанию системной 
 памяти и создать проблемы в работе других приложений. 

Второй метод - PortSentry может связать различные пакеты с программами межсетевой защиты (ipfw, ipfilter, ipfwadm, ipchains, и iptables) так, 
чтобы правила межсетевой защиты могли использоваться для блокирования трафика с определенного IP. PortSentry обнаруживает просмотр и 
добавляет соответствующее правило к конфигурации межсетевой защиты, которая далее заблокирует IP адрес просматриваемого хоста.
Снова, как и с использованием таблиц маршрута, для блокирования трафика, нападающий может подделывать пакеты, заставляя PortSentry 
сообщать межсетевой защите о блокировании самых разных хостов без разбора. Это может привести к блокированию законных хостов 
и доступных сервисов на сканируемом хосте. 

Наконец, правило TCP упаковщика  для IP атакующего может быть добавлено в  системный /etc/hosts.deny файл. 
Он не блокирует просмотр, а просто предотвращает соединение от сканирующего хоста до сервисов, защищенных TCP упаковщиком на 
просматриваемом хосте. Этот метод слаб, по сравнению с двумя предыдущими; однако, в этом случае затруднительно вызвать отказ в 
обслуживании против сканируемой системы.

Может показаться, что управление таблицами маршрутизации или использование правил межсетевой защиты для блокировки сканирования, 
может легко использоваться для блокировки всего трафика на сканируемом хосте, однако это не так. Да, есть опасности в использовании этих методов; 
однако, должным образом конфигурируя PortSentry и контролируя его журналы регистрации, этот риск можно значительно уменьшить. 

Как только просмотр обнаружен, PortSentry продолжает сохранять состояние  на предварительно блокированных хостах, записывая IP адрес 
блокируемого хоста в файл регистрации PortSentry в формате <:protocol>: file (где    - один из TCP или UDP). 
При обнаружении просмотра PortSentry сначала исследует этот файл и только затем использует собственный внутренний массив состояния. 
Если хост был предварительно блокирован, то PortSentry проигнорирует такое сканирование. Блокированный файл каждый раз обновляется 
при перезапуске PortSentry. PortSentry также записывает блокированные хосты в portsentry.history файл. 
Этот файл не перезаписывается при перезапуске, и хранит истории всех блокированных хостов. 
